Johnson 算法 = 「稀疏图 + 负权边 + 全源最短路」的 标准解决方案
    一句话：用 Bellman-Ford 做“势能”把边权整体搬成正数，再对每个点跑堆优化 Dijkstra，最后把距离减回去。
1. 适用场景
    场景	            是否支持
    稀疏图（m ≈ n）	✅ 最擅长
    稠密图（m ≈ n²）	⚠️ 不如 Floyd
    负权边	        ✅
    负环	            ✅
    无向图	        ❌ 保证无负边， 否则必定有负环

2. 算法步骤（3 步）
    1.新建超级源点 S（编号 0），向所有原顶点引 0 权边。
        以 S 为源跑 Bellman-Ford
        得到势能 h[v] = δ(S, v)；
        若发现负环 → 直接输出 -1 结束。
    2.重赋边权（re-weight）
        对每条原边 (u, v, w) 令 w'(u,v) = w(u,v) + h[u] - h[v]
        由三角形不等式可证 w′ ≥ 0。
    3.对每个原顶点 s 跑 堆优化 Dijkstra
        得到以 w′ 为权的全源最短路 d′[s][t]。
        再还原真实距离 d[s][t] = d′[s][t] - h[s] + h[t]

3. 复杂度
    步骤	            复杂度	        说明
    Bellman-Ford	O(nm)	        仅跑一次
    n 次 Dijkstra	O(n m log n)	稀疏图远优于 Floyd
    总复杂度	        O(nm log n)	    常数比 Floyd 大

4. 正确性要点
    路径长度整体平移
        任意 s-t 路径 P 在新图长度
        len'(P) = len(P) + h[s] - h[t]
        与路径形状无关 ⇒ 最短路径相对顺序不变。
    非负性保证
        h[v] ≤ h[u] + w(u,v) ⇒ w'(u,v) ≥ 0，Dijkstra 可用。

