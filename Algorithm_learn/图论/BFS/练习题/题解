迷宫
    题目描述：
        0可以走， 1不可以走，问从左上角到右下角最快几步？到不了返回-1

    例如：
         0 1 0 0 0
         0 1 0 1 0
         0 0 0 1 0
         0 1 0 0 0
         0 0 1 1 0
         返回8
    题解：
        只要迷宫里所有边的长度都是“同一个常数代价”（权重为1），那么第一次碰到目标时的路径长度一定就是最短长度，而 BFS 天生“按层扩散”，第一次弹出就是最短，所以能用
            BFS 的“层号”= 路径长度
            代价必须是“常数 1”
            第一次访问即最优


马走日
    题目描述：
        给一个矩阵， 给一个起点， 起点上的🐎只能走日， 返回一个矩阵（元素为🐎到该点的最小步数， 到不了标记为-1）
    例如：
        3 3 起点为（0, 0）;
        返回： 0  3  2
              3 -1  1
              2  1  4
    题解：
        同迷宫问题， 一样是遍历整个矩阵， 只不过步长有变化， 先让整个矩阵为 -1， 再一边遍历， 一边记录。


染色问题：
    题目描述：
        给一个矩阵， 只含0、 1，矩阵有一部分0被1包围， 一部分0未被包围， 仅将包围的0变成2。
    例如：
        0 0 0 0 0 0
        0 1 1 1 1 1
        0 0 1 0 0 1
        0 1 0 0 0 1
        0 1 1 1 1 1
        返回：0 0 0 0 0 0
             0 1 1 1 1 1
             0 0 1 2 2 1
             0 1 2 2 2 1
             0 1 1 1 1 1
    题解：
        一样是用BFS的方法， 只不过可以先将1外面的0标记为false， 然后再进行遍历，只不过要留一个1作为遍历的起点

陨石问题：
    题目描述：
        一个矩阵， 在不同的时间会落下一个或多个陨石， 被陨石击中的点，四联通区域均会被污染， 一个人要逃到安全的地方，逃出生天返回步数， 否则返回-1（起点在（1，1）， 不可被击中，也不可走污染点）
    例如：
        击中矩阵：
            1 1 INF
            2 3 INF
            INF IFN 4
        污染矩阵：
            1 1 1
            1 1 3
            2 3 4
        返回 -1
    题解：
        先生成一个污染矩阵， 再进行遍历（途中记录步数， 比较是否被击中）， 最后返回 步数 或 -1

汽车拉力赛：
    题目描述：
        给一个矩阵表达地图的海拔， 再给一个矩阵只含0与1， 1表示标记点。 现从任意一个标记点出发，途径所有其他标记点，只能四个方向走，求两个格子之间海拔的最小最大高度差为D，返回D;
    例如：
        海拔矩阵 和路标矩阵：
            1 2 3 4     1 0 0 1
            4 5 4 2     0 0 1 0
            1 2 2 6     1 0 0 0
        返回2
    题解：
        肯定用BFS， 但如何解决最小最大高度差， 用二分法， 一步一步逼近答案，上线是max-min, 下线为-1， 取中间值进行二分。

小明的游戏：
    题目描述：
        小明从起点出发， 到达终点，途径@#两个字符， 从同一个字符经过时不加步数，不同字符经过时加步数， 问最短步数为？
    例如：
        输入矩阵大小：
            3 3
        起点，终点：
            0 0 2 2
        地图：
            @@#
            #@#
            ##@
        返回2
    题解：
        这是一种涉及到0~1边权的最短路径问题， 可以用Dijkstra解决， 但用BFS可以更快：
            0~1边权BFS， 做法 利用双端队列， 0往队首加， 1往队尾加（先走0再走1），用dist数组记录移动步数，把矩阵遍历一遍就行了

八数码&魔板：
    题目描述：
        类似于华容道， 有一个空格， 通过变化到达目标位置， 返回步数
    例如：
        2 3 5      1 2 3
        6 1 4  --> 8 0 4
        8 7 0      7 6 5
    输入：
        235614870
        返回18
    题解：
        用字符串记录矩阵状态
            双向BFS + 康托压缩
                已知开头和结尾， 两边同时进行搜索， 当碰头时就返回结果；
                康托压缩： 哈希表特定情况下的优替， 将排列 --> 整数






