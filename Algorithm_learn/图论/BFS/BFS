BFS总结：
    一句话：BFS = 层序 + 队列，“一层一层扩，最短自然来”

    几大类型：
        1. 单源BFS
            压入队列，直接遍历， 基础BFS
                eg: 迷宫问题
        2. 多源BFS
            本质：初始 多个源点 同时入队，求 最晚被波及 的时间/距离
        3. 0~1边权问题
            边权只有 0 或 1，用 【双端队列】 保证“0 边先出”
                eg: 小明的游戏
        4. 双向 BFS
            从 起点 + 终点 同时扩展，首次相遇即最短 ， 前提是已知起点和终点
                eg:  8数码难题
    几大优化：
        1. 双向BFS
            如果已知起点和终点状态， 求两者之间的最短路径， 可以用双向BFS， 起点和终点同时开始搜索， 当两者的扩散相碰时结束。
                正常时间复杂度：
                    O( q^k ) 其中q为树的平均分支， k是树的高度
                双向BFS时间复杂度：
                    O( 2 * q^(k/2) ) 其中q为树的平均分支， k是树的高度
        2. 康托压缩
            把「排列 → 唯一整数」 的映射技巧， 常用于 排列哈希、状态压缩 DP、博弈论状态判重。
            ✅ 一句话理解
            「把 1~n 的排列压成 0~(n!-1) 的唯一整数。」
            代码：
                1. 从 排列 --> 整数
                    #include <vector>
                    using namespace std;

                    // 将排列（可以用数组存，也可以用string存）转换成整数
                    long long cantor(const vector<int>& a) {
                        int n = a.size();
                        long long rank = 0;
                        for (int i = 0; i < n; ++i) {
                            int cnt = 0;
                            for (int j = i + 1; j < n; ++j)
                                if (a[j] < a[i]) ++cnt;
                            rank += cnt * factorial(n - i - 1);
                        }
                        return rank;
                    }

                    // 生成x!
                    long long factorial(int x) {
                        long long f = 1;
                        for (int i = 2; i <= x; ++i) f *= i;
                        return f;
                    }

                2. 从 整数 --> 排列
                    // 都会利用到factor函数，所以得提前写上
                    vector<int> invCantor(long long rank, int n) {
                        vector<int> a(n), used(n, 0);
                        for (int i = 0; i < n; ++i) {
                            long long fact = factorial(n - i - 1);
                            int cnt = rank / fact;
                            rank %= fact;
                            for (int j = 0; j < n; ++j) {
                                if (!used[j] && cnt-- == 0) {
                                    a[i] = j + 1;  // 1-based
                                    used[j] = 1;
                                    break;
                                }
                            }
                        }
                        return a;
                    }

                时间复杂度： O(n^2) n是排列位数

            什么时候用?
                只要总共数据有n!个， 且相互独立（如同排列一般）， 【索引由排列构成】就可以用

            还有优化版本， Fenwick 树（BIT）优化
                代码：


                时间复杂度： O(nlogn) n是排列位数

            选择版本：
                n <= 8
                    用法一
                n >= 12
                    用法二









