KMP原理介绍：
    本质上是为了让主字符串的指针不往回溯， 通过前面匹配的"经验", 指导后面的匹配
    如图：
        [A]a____[A]p
        [A]a____[A]x
        当出现不匹配的时候， 主指针不会立刻回溯， 而是让a去与p比较：
            若 p == a, 则这样继续比：
                [A]a____[A]ap
                        [A]ax
            若 p != a, 找到A中的 'a', 继续比 A = [B]b____[B]:
                [A]a____[B]b____[B]p
                                [B]b
                以此类推
        为什么你可以这么从容地将[A]a直接跳到[A]p, 就不怕中间的____凑出答案从而错过正解吗？
            当然不可能， 如图：
                如果有, 且要满足答案，就要长这样：
                    [A]a__[A]a__[A]p
                          [A]a__[A]__[A]x
                    但这也表明了 -> a__, a__, a__, __这四段要一模一样 -> [A]a__[A]a__[A] 有更长最长前后缀 [AA] , 其中 [AA]-> [A]a_, 这显然不合情况， 因为[A] 已经是最长的了。


KMP辅助工具--> next数组求法：
    根据上面的过程， 发现最长前后缀就是我们的一个重要工具， 而next数组就是一个求每个字符串最长前后缀用的；
        动脑子想一想也知道一个最简单易懂的方法：
            给一个字符串，直接遍历他不就行了， eg:
                法一： 从小到大遍历
                "aabaa" -> a : a √
                        -> aa : aa √
                        -> aab : baa ×
                        -> aaba : abaa ×
                        所以 最长前后缀为 2
                法二： 从大到小遍历
                "aabaa" -> aaba : abaa ×
                        -> aab : baa ×
                        -> aa : aa √
                        返回 2
            简单是简单， 但让计算机实现， 步骤非常繁琐， 且耗时极长
        再想一个方法， 可不可以和KMP思路一样，利用前面匹配的"经验", 为后面的匹配提供"指导"
            如图：
                假设前面已经匹配好了一次, A是前一次的最长前后缀, p是下一个字符（后缀末尾）, j是新前缀末尾
                [A]j___[A]p
                    若 j == p, 则进行下一个比较:
                        [B]____[B]x
                    若 j != p:, 找的A字符串的最长前后缀[a]
                        [A] -> [a]__[a]
                        则[A]j___[A]p  变为 [a]i_[a]j___[a]i_[a]p
                            判断 i是否等于p:
                                若等于：
                                    返回[a]i长度， 进行下一位比较
                                若不相等：
                                    取[a]的最长前后缀进行比较
            最后就可以获得next数组

KMP复杂度分析：
    next:
        时间复杂度：
            O(N), N是模式串的长度
        空间复杂度：
            O(N), N是模式串的长度

    search:
        时间复杂度：
            O(N+W), N是主字符串长度,W是模式串的长度
        空间复杂度：
            O(W), W是模式串的长度